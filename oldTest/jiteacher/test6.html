<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
//scope作用域链
//    function a() {
//        function b() {
//            var bb = 234;
//            aa = 0;
//        }
//        var aa = 123;
//        b();
//        console.log(aa);
//    }
//    var glob = 100;
//    a();

//    function a() {
//        function b() {
//            function c() {
//
//            }
//            c();
//        }
//        b();
//    }
//    a();

    //!!!!!整个过程的作用域链的产生与消除如下，在访问变量时，一定是遵循着相应的
    //函数的作用域链去访问的。
    //而且里面所有的aAO、bAO都是一个对象，一改都会改
//    a define -> a.[[scope]] -->0 : GO
//
//    a doing  -> a.[[scope]] -->0 : aAO
//                               1 : GO
//
//    b define -> b.[[scope]] -->0 : aAO
//                               1 : GO
//
//    b doing  -> b.[[scope]] -->0 : bAO
//                               1 : aAO
//                               2 : GO
//
//    c define -> c.[[scope]] -->0 : bAO
//                               1 : aAO
//                               2 : GO
//
//    c doing  -> c.[[scope]] -->0 : cAO
//                               1 : bAO
//                               2 : aAO
//                               3 : GO


    //闭包！！！！！
//    function a() {
//        function b() {
//            var bbb = 234;
//            document.write(aaa);
//        }
//        var aaa = 123;
//        return b;
//    }
//
//    var glob = 100;
//    var demo = a();
//    demo();

    //闭包！！！！！！！！！
//    function a() {
//        var num = 100;
//        function b() {
//            num++;
//            console.log(num);
//        }
//        return b;
//    }
//    var demo = a();
//    demo();
//    demo();

    //1.实现公有变量，闭包实现的累加器
//    function add() {
//        var count = 0;
//        function demo() {
//            count++;
//            console.log(count);
//        }
//        return demo;
//    }
//    var counter = add();
//    counter();
//    counter();
//    counter();
//    counter();
//    counter();
//    counter();
//    counter();
//    counter();

    //2.可以做缓存（存储结构）
//    function test() {
//        var num = 100;
//        function a() {
//            num++;
//            console.log(num);
//        }
//        function b() {
//            num--;
//            console.log(num);
//        }
//        return [a,b];
//    }
//
//    var myArr = test();
//    myArr[0]();
//    myArr[1]();
    //两者保存的aAO是一个ao，所以改的都是在同一个基础上删改。所以先加后减

//    function eater() {
//        var food = "";
//        var obj = {
//            eat : function () {
//                console.log("i am eating " + food);
//            },
//            push : function (myFood) {
//                food = myFood;
//            }
//        }
//        return obj;
//    }
//
//    var eater1 = eater();
//
//    eater1.push('banana');
//    eater1.eat();

    //闭包升级
//    function test() {
//        var arr = [];
//        for(var i = 0;i < 10;i++) {
//            arr[i] = function () {
//                document.write(i + " ");
//            }
//        }
//        return arr;
//    }
//
//    var myArr = test();
//    for(var j = 0;j < 10;j++){
//        myArr[j]();
//    }

        //!!!非常重要，用闭包解决闭包！利用立即执行函数，随时把函数结果调出来。这样就避免了数值被一轮轮覆盖。
//        function test() {
//            var arr = [];
//            for (var i = 0; i < 10; i++) {
//                arr[j] = (function (j) {
//                    document.write(j + " ");
//                }(i))
//            }
//            return arr;
//        }
//        var myArr = test();
//        for(var j = 0;j < 10;j++){
//            myArr[j]();
//        }










    //闭包的其他功能，日后再说
    //可以实现私有化，封装
    //模块化开发，可以防止污染全局变量环境

</script>
</body>
</html>